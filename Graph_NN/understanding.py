# -*- coding: utf-8 -*-
"""Undestanding the GNN.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1sfFVNbOWCXn8lSI9uSLNs2oSfJEuyXXW
"""

! python -c "import torch; print(torch.version.cuda)"
! python -c "import torch; print(torch.__version__)"

!pip install torch_geometric
!pip install torch-scatter -f https://data.pyg.org/whl/torch-2.1.0+cu121.html
!pip install torch-sparse -f https://data.pyg.org/whl/torch-2.1.0+cu121.html
import torch
import torch_geometric

from torch_geometric.data import Data

"""# Creating my own Data and plotting in the networkx"""

x=torch.tensor([[1],[0],[-1]], dtype=torch.float)
edge_index=torch.tensor([[1,0,0,2],[2,0,1,2]],dtype=torch.long)
from torch_geometric.utils import to_networkx
data=Data(x=x,edge_index=edge_index)
!pip install networkx
import networkx as nx
G=to_networkx(data)
nx.draw(G)

data

print(data.num_nodes)
print(data.num_edges)
print(data.is_directed())
print(data.has_self_loops())
print(data.x)
print(data.keys)
print(data.num_features)

"""# Example - 2"""

x=torch.tensor([[[1],[1],[1]],[[1],[3],[3]]],dtype=torch.long)
edge_index=torch.tensor([[2,3,4,5],[1,2,3,4]],dtype=torch.float)
data=Data(x=x,edge_index=edge_index)
from torch_geometric.utils import to_networkx
G1=to_networkx(data)
nx.draw(G1)

print(data.num_nodes)
print(data.num_edges)
print(data.num_node_features)
print(data.x)
print(data.edge_index)
print(data)

print(x.ndim)
print(edge_index.ndim)

print(G1.number_of_nodes())
print(G1.number_of_edges())

"""# Making the colorful Graphs"""

import networkx as nx
import matplotlib.pyplot as plt

G=nx.Graph()
G.add_edge(1,2)
G.add_edge(2,3)
nx.draw(G,cmap=plt.get_cmap('viridis'),node_color=G,with_labels=True)
A=nx.adjacency_matrix(G)
print(A.todense())

"""# Explaining the concept of weighted and non-weighted graphs"""

G=nx.Graph()
G.add_edge(1,2,weight=1)
G.add_edge(2,3,weight=2)
A=nx.adjacency_matrix(G)
print(A.todense())
print(nx.is_directed(G))
print(nx.is_weighted(G))
G.add_edge(1,1)
print(nx.is_directed(G))
print(nx.is_weighted(G))

"""# Making the Incidence Matrix"""

G=nx.Graph()
G.add_edge(1,2,weight=1)
G.add_edge(2,3,weight=5)
G.add_edge(1,1)
G.add_edge(2,2)
G.add_edge(3,3)
I=nx.incidence_matrix(G)
print(I.todense())

"""# Making the Laplacian Matrix"""

A=nx.adjacency_matrix(G)
print(A.todense())
L=nx.laplacian_matrix(G)
print(L.todense())

"""# Making the incidence matrix for The DiGraph"""

G=nx.DiGraph()
G.add_edge(1,2,weight=1)
G.add_edge(2,3,weight=2)
nx.draw(G,cmap=plt.get_cmap('viridis'),node_color=G,with_labels=True)
I=nx.incidence_matrix(G)
print(I.todense())
print(I.diagonal())

A=nx.adjacency_matrix(G)
print(A.todense())

G.edges

G.nodes

print(G.number_of_nodes())
print(G.number_of_edges())

"""# Explaining the coloring in the directed Graph"""

G=nx.Graph()
G.add_edges_from([('A','B'),('B','C'),('C','A'),('D','B')])
print(G.edges)
print(G.nodes)
val_graph={'A':0.1,
           'B':0.2,
           'C':0.3}
values=[]
for node in G.nodes:
  values.append(val_graph.get(node,0.25))
# values=[0.25,0.25,0.25,0.25]
nx.draw(G,cmap=plt.get_cmap('viridis'),node_color=values,with_labels=True)

"""# Making a particular graph with the edges label also"""

G=nx.Graph()
G.add_edges_from([('A','B'),('B','B'),('B','D'),('D','F'),('F','F'),('F','C'),('F','E'),('E','C'),('C','A')])
value_graph=({'A':0.1,'B':0.2,'C':0.3,'D':0.3,'E':0.2,'F':0.1})
values=[value_graph.get(node,0.25) for node in value_graph]
nx.draw(G,node_color=values,cmap=plt.get_cmap('viridis'),with_labels=True)

nx.draw(G.to_directed(),node_color=values,cmap=plt.get_cmap('viridis'),with_labels=True)

edge_labels={('A','B'):'e1',('B','B'):'e2',('B','D'):'e3',('D','F'):'e4',('F','F'):'e5',('F','C'):'e6',('F','E'):'e7',('E','C'):'e8',('C','A'):'e9'}
pos=nx.spring_layout(G)
nx.draw(G,pos,node_color=values,with_labels=True,edge_color='blue')
nx.draw_networkx_edge_labels(G,pos,edge_labels=edge_labels,font_color='red')

"""# Random Walk"""

import networkx as nx
G=nx.Graph()
G.add_node(2)
G.add_node(1)
G.add_edge(1,2)
G.add_edge(3,4)
G.add_edge(2,3)
G.add_edge(4,1)
G.add_edge(5,1)
G.add_edge(5,4)
G.add_edge(7,2)
G.add_edge(7,6)
G.add_edge(6,6)
nx.draw(G)

import random
def perform_random_walk(G,node,path_length):
  random_result=[node]
  for i in range(0,(path_length-1)):
    temp=list(G.neighbors(node))
    temp=list(set(temp)-set(random_result))
    if(len(temp)==0):
      break
    random_choice=random.choice(temp)
    node=random_choice
    random_result.append(node)
  return(random_result)

perform_random_walk(G,1,7)

from tqdm import tqdm
random_walks=[]
for node in tqdm(G.nodes):
  for i in range (3):
    random_walks.append(perform_random_walk(G,node,i+1))
print(len(random_walks))
print(random_walks)

"""# Importing the understanding the dataset"""

import torch_geometric
import networkx as nx
import matplotlib.pyplot as plt
from torch_geometric.datasets import KarateClub
dataset=KarateClub()
print(f" Number of the Graphs in the dataset: {len(dataset)}")
print(f" Number of the classes in the dataset: {dataset.num_classes}")
print(f" Number of the node features in the dataset: {dataset.num_node_features}")
print(f" Number of the edge features in the dataset: {dataset.num_edge_features}")

"""# Importing the data and understanding the data"""

data=dataset[0]
print(data)
print(f"The node feature of the data{data.x}")
print(f"The edge list of the data{data.edge_index}")
print(f"The output of the data{data.y}")
print(f"The train_mask of the data{data.train_mask}")
print(f"The number of nodes in the data{data.num_nodes}")
print(f"The number of edge in the data{data.num_edges}")
print(f"The average degree in the data {data.num_edges/data.num_nodes}")
print(f"The directed??{data.is_directed()}")
print(f"The train mask sum{data.train_mask.sum()}")
print(f"the features for 1 node {data.x[0]} ")

"""# Looking the data in a different manner"""

print(data.to_dict())
print(data.edge_index.t())

# Visualizing the Graph
from torch_geometric.utils import to_networkx
karate_club_graph=to_networkx(data)
nx.draw(karate_club_graph,node_color=data.y,cmap='Set2',with_labels=True)

# Visualizing the Graph
from torch_geometric.utils import to_networkx
karate_club_graph=to_networkx(data,to_undirected=True)
nx.draw(karate_club_graph,node_color=data.y,cmap='Set2',with_labels=True)

"""# GCN"""

import torch
from torch.nn import Linear
from torch_geometric.nn import GCNConv
class GCNModule(torch.nn.Module):
  def __init__(self):
    super().__init__()
    self.conv1=GCNConv(dataset.num_features,4)
    self.conv2=GCNConv(4,4)
    self.conv3=GCNConv(4,2)
    self.classifier=Linear(2,dataset.num_classes)
  def forward(self,x,edge_index):
    h=self.conv1(x,edge_index)
    h=h.tanh()
    h=self.conv2(h,edge_index)
    h=h.tanh()
    h=self.conv3(h,edge_index)
    h=h.tanh()
    out=self.classifier(h)
    return out,h
model=GCNModule()
print(model)

model=GCNModule()
_,h=model(data.x,data.edge_index)
print(h)

def visualize_embedding(h,color,epoch=None,loss=None):
  plt.figure(figsize=(12,8))
  h=h.detach().cpu().numpy()
  plt.scatter(h[:,0],h[:,1],s=140,c=color,cmap="Set2")
  plt.show()
visualize_embedding(h,data.y)
